[TOC]



## 1. 程序(a.out) vs 进程

![](01.png)



## 2. 一个 ==程序== 运行后，唯一对应一个 ==进程==，并拥有自己 ==独立的进程空间==

![](02.png)



## 3. C 语言中的 ==指针类型== 占用的 ==字节数== 刚好等于 ==CPU 位数(寻址长度)==

```c
sizeof(void*)
```

- 在 **32 位** 的 编译器 和 操作系统 中，值为 **4 字节 (32 位)**
- 在 **64 位** 的 编译器 和 操作系统 中，值为 **8 字节 (64 位)**



## 4. 虚拟地址空间，并不能任意使用 (32位 虚拟地址空间 为例)

![](03.png)

## 5. 进程 不能完全使用剩下的 3G 虚拟空间

![](04.png)



## 6. 程序执行(==装载==) 的 2种 方式

![](05.png)

-----

- 1、覆盖 Overlay
- 2、页映射 Paging



## 7. 程序装载1: 覆盖 (Overlay)

### 1. ==模块== 为 ==单位== 划分与装载 程序文件

![](06.png)

![](07.png)

### 2. 实际中使用 ==树结构== 组织所有的 ==模块==


![](08.png)

![](09.png)

### 3. 调用 路径

![](23.png)




## 8. 程序装载2: 页映射 (Paging)

### 1. ==页== 为 ==单位== 划分与装载 程序文件

![](10.png)

![](11.png)

### 2. 页 ==映射==

![](12.png)

![](13.png)

通常是 LRC 页淘汰算法。



## 9. 从 ==操作系统== 角度来看 ==可执行文件== 的 ==加载== (创建进程)

### 1. 主要是 3 件事情

![](14.png)

### 2. 事情1: 创建 ==虚拟地址空间==

![](15.png)

![](16.png)

### 3. 事情2: 读取 可执行文件 ==头部== ，建立 ==虚拟地址空间== 与 ==可执行文件== 映射关系 (==VMA== 存储 ==映射关系==)

![](17.png)

![](18.png)

![](19.png)



### 4. 事情3:  将 CPU ==指令 寄存器== 的值，设置为 可执行文件 ==入口符号== 开始执行

![](20.png)



## 10. 页 ==错误==

![](21.png)

![](22.png)



## 11. elf 文件的 ==链接视图== vs ==运行视图==

### 1. elf 文件中包含的 ==多个段(section)== 载入到进程空间中 ==不同地址处 (VMA)==

![](24.png)

### 2. 当段的 ==数量增多== 时，就会产生 ==空间浪费 (页对齐)== 问题

![](25.png)

### 3. 段的 ==权限== 种类就 3种

![](26.png)

### 4. 解决因 ==页对齐== 造成的空间浪费: 将多个 ==权限相同== 的段当做 ==一个段== 映射到虚拟地址空间

![](27.png)

---

- 将 **多个段(section)** 在 **运行(加载到内存)** 时，**当做** 一个 **大的段** 分配 **页**
- 可大大减小因为 **页对齐** 带来的 **空间浪费**
- 一个 **Segment** 只是在 **运行时** 表示 将多个段 **逻辑上当做** 一个大的段完成 **页分配**
-  **Segment** 并 **不是** 在 **物理** 上合并了多个段

### 5. elf ==可执行文件== 中的 ==Segment== 结构: 在程序 ==运行== 时，将多个物理段，映射到一个虚拟空间中

![](28.png)

![](29.png)

### 6. ==目标文件== 链接生成 ==可执行文件== 后的存在的 ==段(section)==

![](30.png)

![](31.png)

### 7. readelf -l 查看 ==可执行文件== 的 ==Segment==

![](32.png)

------

- 只关心 **LOAD** 类型的 Segment
- 因为只有 **LOAD** 类型的 Segment 才会被 **装载到内存**
- 其他类型的 Segment 仅仅只是在 **装载** 时起到 **辅助作用** 

### 8. 只有 ==LOAD== 类型的 ==Segment== 才会被 ==装载到内存==

![](33.png)

![](34.png)

### 9. Segment(==执行==视图) vs Section(==链接==视图)

![](35.png)

### 10. elf 可执行文件 中的 ==Program Header Table== 保存 Segment 信息

#### 1. Program Header Table 对应的代码就是一个 ==结构体数组==

![](36.png)

#### 2. 结构体成员变量含义

![](37.png)

![](38.png)

### 11. 但是 elf ==目标文件== 没有 ==Program Header Table== 

- 因为 elf **目标文件** 仅仅只是 **编译阶段** 的产物
- 而且 elf **目标文件** 不能够 **执行**
- 所以并 **不需要** Program Header Table 保存 Segment 信息



