[TOC]



## 1. 程序(a.out) vs 进程

![](01.png)



## 2. 一个 ==程序== 运行后，唯一对应一个 ==进程==，并拥有自己 ==独立的进程空间==

![](02.png)



## 3. C 语言中的 ==指针类型== 占用的 ==字节数== 刚好等于 ==CPU 位数(寻址长度)==

```c
sizeof(void*)
```

- 在 **32 位** 的 编译器 和 操作系统 中，值为 **4 字节 (32 位)**
- 在 **64 位** 的 编译器 和 操作系统 中，值为 **8 字节 (64 位)**



## 4. 虚拟地址空间，并不能任意使用 (32位 虚拟地址空间 为例)

![](03.png)

## 5. 进程 不能完全使用剩下的 3G 虚拟空间

![](04.png)



## 6. 程序执行(==装载==) 的 2种 方式

![](05.png)

-----

- 1、覆盖 Overlay
- 2、页映射 Paging



## 7. 程序装载1: 覆盖 (Overlay)

### 1. ==模块== 为 ==单位== 划分与装载 程序文件

![](06.png)

![](07.png)

### 2. 实际中使用 ==树结构== 组织所有的 ==模块== (==调用路径==)

![](08.png)

![](09.png)




## 8. 程序装载2: 页映射 (Paging)

### 1. ==页== 为 ==单位== 划分与装载 程序文件

![](10.png)

![](11.png)

### 2. 页 ==映射==

![](12.png)

![](13.png)

通常是 LRC 页淘汰算法。



## 9. 从 ==操作系统== 角度来看 ==可执行文件== 的 ==加载== (创建进程)

### 1. 主要是 3 件事情

![](14.png)

### 2. 事情1: 创建 ==虚拟地址空间==

![](15.png)

![](16.png)

### 3. 事情2: 读取 可执行文件 ==头部== ，建立 ==虚拟地址空间== 与 ==可执行文件== 映射关系 (==VMA== 存储 ==映射关系==)

![](17.png)

![](18.png)

![](19.png)



### 4. 事情3:  将 CPU ==指令== 寄存器的值，设置为 可执行文件 ==入口符号== 开始执行

![](20.png)



